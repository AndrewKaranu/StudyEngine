#include <Wire.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <TFT_eSPI.h> 
#include <MFRC522.h>

// ===================================================================================
// PIN DEFINITIONS & CONFIGURATION
// ===================================================================================

// --- I2C DEVICES ---
#define PCF_ADDR     0x20 // Check if your module is 0x20 or 0x27
#define OLED_ADDR    0x3C
#define CARDKB_ADDR  0x5F
#define I2C_SDA      21
#define I2C_SCL      22

// --- SPI DEVICES (Shared VSPI Bus) ---
// TFT and RFID share SCK, MISO, MOSI
// TFT Pins: CS=13, RST=4, DC=2
// RFID Pins: CS=15, RST=33
#define SPI_SCK      5
#define SPI_MISO     19
#define SPI_MOSI     23

#define TFT_CS       13
#define TFT_DC       2
#define TFT_RST      4 

#define RFID_CS      15
#define RFID_RST     33

// --- ANALOG & AUDIO ---
#define PIN_IR       34 // Analog Input
#define PIN_POT      35 // Analog Input
#define PIN_PIR      27 // Digital Input (Moved from PCF8575)
#define PIN_SPKR     25 // DAC Output

// --- LORA (Disable) ---
#define LORA_CS      18
#define LORA_RST     14

// --- PCF8575 PIN MAPPING (0-15) ---
#define PCF_BTN_A    0
#define PCF_BTN_B    1
#define PCF_BTN_C    2
#define PCF_BTN_D    3
// #define PCF_PIR      5 // Moved to GPIO 27
#define PCF_LED_R    6
#define PCF_LED_G    7
#define PCF_LED_B    8

// ===================================================================================
// OBJECTS
// ===================================================================================
Adafruit_SSD1306 oled(128, 64, &Wire, -1);
TFT_eSPI tft = TFT_eSPI(); 
// SPIClass rfidSpi(HSPI); // Removed: Library doesn't support it
MFRC522 rfid(RFID_CS, RFID_RST); // Use default constructor (uses global SPI)

// ===================================================================================
// GLOBALS
// ===================================================================================
uint16_t pcfState = 0xFFFF; // Default all high (input mode)
unsigned long lastUpdate = 0;

// Menu System
enum SystemState { STATE_MENU, STATE_DIAG, STATE_RGB, STATE_PIR, STATE_SPEAKER };
SystemState currentState = STATE_MENU;
SystemState lastState = STATE_PIR; // Force initial redraw
int menuIndex = 0;
int lastMenuIndex = -1;
const int MENU_ITEMS = 4;
const char* menuLabels[] = {"Diagnostics", "RGB LED Test", "PIR Sensor Graph", "Speaker Test"};

// RGB Test
int rgbStep = 0;
int lastRgbStep = -1;
unsigned long lastRgbTime = 0;

// PIR Graph
#define GRAPH_W 240
int pirGraphX = 0;
byte pirHistory[GRAPH_W]; // 0 or 1

// ===================================================================================
// HELPER FUNCTIONS FOR PCF8575 (No Library Needed)
// ===================================================================================
void pcfWrite(uint16_t data) {
  Wire.beginTransmission(PCF_ADDR);
  Wire.write(data & 0xFF);
  Wire.write((data >> 8) & 0xFF);
  Wire.endTransmission();
  pcfState = data;
}

uint16_t pcfRead() {
  Wire.requestFrom(PCF_ADDR, 2);
  if (Wire.available() == 2) {
    uint16_t data = Wire.read();
    data |= (Wire.read() << 8);
    return data;
  }
  return 0xFFFF;
}

// Helper to set specific PCF pin
void pcfSetPin(int pin, bool value) {
  if (value) pcfState |= (1 << pin);
  else       pcfState &= ~(1 << pin);
  pcfWrite(pcfState);
}

// ===================================================================================
// SETUP
// ===================================================================================
void setup() {
  Serial.begin(115200);
  Serial.println("\n--- SMART STUDY COMPANION SYSTEM TEST ---");

  // 1. Disable LoRa
  pinMode(LORA_CS, OUTPUT); digitalWrite(LORA_CS, HIGH);
  pinMode(LORA_RST, OUTPUT); digitalWrite(LORA_RST, LOW);

  pinMode(PIN_PIR, INPUT); // Init PIR

  // 2. Init I2C
  Wire.begin(I2C_SDA, I2C_SCL);
  
  // 3. Init PCF8575
  // Write 1s to Input pins (P0-P5) to enable pull-ups/input mode
  // Write 0s to Output pins (P6-P8) to start them OFF
  // 0000 0001 1111 1111 -> 0x01FF (P9-P15 High/Input, P6-P8 Low/Out, P0-P5 High/In)
  // Actually, let's keep P9-P15 high just in case.
  // Inputs: 0,1,2,3,4,5 -> Bits 0-5 HIGH
  // Outputs: 6,7,8 -> Bits 6-8 LOW (Off)
  // Mask: 1111 1110 0011 1111 -> 0xFE3F
  pcfState = 0xFE3F; 
  pcfWrite(pcfState);

  // 4. Init OLED
  if(!oled.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR)) {
    Serial.println("OLED Init Failed!");
  } else {
    oled.clearDisplay();
    oled.setTextSize(1);
    oled.setTextColor(WHITE);
    oled.setCursor(0,0);
    oled.println("System Test...");
    oled.display();
  }

  // --- MANUAL TFT RESET ---
  pinMode(TFT_RST, OUTPUT);
  digitalWrite(TFT_RST, HIGH); delay(50);
  digitalWrite(TFT_RST, LOW);  delay(50);
  digitalWrite(TFT_RST, HIGH); delay(150);

  // 5. Init TFT
  tft.init();
  tft.setRotation(3); // Changed to 3 to fix mirroring/orientation
  tft.fillScreen(TFT_BLACK);
  
  // UI will be drawn in loop() based on mode

  // 6. Init RFID (Shared Bus)
  SPI.begin(SPI_SCK, SPI_MISO, SPI_MOSI);
  rfid.PCD_Init();
  
  // Debug RFID Version
  byte v = rfid.PCD_ReadRegister(rfid.VersionReg);
  Serial.print("RFID Version: 0x"); Serial.println(v, HEX);
  if (v == 0x00 || v == 0xFF) {
    Serial.println("WARNING: RFID Communication Failed! Check Wiring.");
    tft.setCursor(0, 220);
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.print("RFID ERROR: CHECK WIRING");
  }
  
  // 7. Init Audio (LEDC)
  // For ESP32 Arduino Core v3.0+
  ledcAttach(PIN_SPKR, 2000, 8); // Pin, Freq, Resolution
  
  // Play startup tone
  ledcWriteTone(PIN_SPKR, 1000); delay(100);
  ledcWriteTone(PIN_SPKR, 2000); delay(100);
  ledcWriteTone(PIN_SPKR, 0);

  Serial.println("Setup Complete.");
}

// ===================================================================================
// LOOP
// ===================================================================================
void loop() {
  // Run loop faster for inputs, but update UI slower
  static unsigned long lastUiUpdate = 0;
  
  // --- READ SENSORS (Fast) ---
  uint16_t pcfInputs = pcfRead();
  int potVal = analogRead(PIN_POT);
  int irVal = analogRead(PIN_IR);
  
  // Extract PCF Inputs (LOW = Active/Pressed)
  bool btnA = !((pcfInputs >> PCF_BTN_A) & 1);
  bool btnB = !((pcfInputs >> PCF_BTN_B) & 1);
  bool btnC = !((pcfInputs >> PCF_BTN_C) & 1);
  bool btnD = !((pcfInputs >> PCF_BTN_D) & 1);
  bool pir  = digitalRead(PIN_PIR); 

  // --- STATE MACHINE ---
  switch (currentState) {
    
    // *** MAIN MENU ***
    case STATE_MENU:
      // Map Pot to Menu Index
      menuIndex = map(potVal, 0, 4096, 0, MENU_ITEMS);
      if (menuIndex >= MENU_ITEMS) menuIndex = MENU_ITEMS - 1;

      // Redraw only if state changed or selection changed
      if (currentState != lastState || menuIndex != lastMenuIndex) {
        if (currentState != lastState) tft.fillScreen(TFT_BLACK);
        
        tft.setTextSize(2);
        tft.setCursor(0, 0);
        tft.setTextColor(TFT_CYAN, TFT_BLACK); tft.println(" MAIN MENU");
        tft.drawLine(0, 20, 320, 20, TFT_WHITE);
        
        for (int i = 0; i < MENU_ITEMS; i++) {
          tft.setCursor(20, 50 + (i * 40));
          if (i == menuIndex) {
            tft.setTextColor(TFT_YELLOW, TFT_BLACK); tft.print("> ");
          } else {
            tft.setTextColor(TFT_BLACK, TFT_BLACK); tft.print("  "); // Clear arrow
            tft.setTextColor(TFT_WHITE, TFT_BLACK); 
          }
          tft.println(menuLabels[i]);
        }
        
        tft.setCursor(0, 220);
        tft.setTextColor(TFT_DARKGREY, TFT_BLACK); tft.print("Pot:Scroll  BtnA:Select");
        
        lastState = currentState;
        lastMenuIndex = menuIndex;
      }
      
      // Selection Logic
      if (btnA) {
        if (menuIndex == 0) currentState = STATE_DIAG;
        else if (menuIndex == 1) currentState = STATE_RGB;
        else if (menuIndex == 2) { currentState = STATE_PIR; pirGraphX = 0; memset(pirHistory, 0, GRAPH_W); }
        else if (menuIndex == 3) currentState = STATE_SPEAKER;
        delay(300); // Debounce
      }
      break;

    // *** DIAGNOSTICS MODE ***
    case STATE_DIAG:
      // Initial Draw
      if (currentState != lastState) {
        tft.fillScreen(TFT_BLACK);
        tft.setTextSize(2);
        tft.setCursor(0, 0); tft.setTextColor(TFT_CYAN, TFT_BLACK); tft.println(" SYSTEM DIAGNOSTICS");
        tft.drawLine(0, 20, 320, 20, TFT_WHITE);
        tft.setCursor(0, 40); tft.setTextColor(TFT_YELLOW, TFT_BLACK); tft.print("Buttons: ");
        tft.setCursor(0, 70); tft.setTextColor(TFT_WHITE, TFT_BLACK); tft.print("Pot: ");
        tft.setCursor(0, 100); tft.print("IR: ");
        tft.setCursor(0, 130); tft.print("PIR: ");
        tft.setCursor(0, 160); tft.setTextColor(TFT_MAGENTA, TFT_BLACK); tft.print("RFID: ");
        tft.setCursor(0, 190); tft.setTextColor(TFT_ORANGE, TFT_BLACK); tft.print("Key: ");
        tft.setCursor(0, 220); tft.setTextColor(TFT_DARKGREY, TFT_BLACK); tft.print("BtnB: Back to Menu");
        lastState = currentState;
      }

      if (millis() - lastUiUpdate > 100) {
        lastUiUpdate = millis();
        
        // RFID Check
        bool rfidDetected = false;
        String rfidUid = "";
        if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
          rfidDetected = true;
          for (byte i = 0; i < rfid.uid.size; i++) rfidUid += String(rfid.uid.uidByte[i], HEX);
          ledcWriteTone(PIN_SPKR, 3000); delay(50); ledcWriteTone(PIN_SPKR, 0);
        }

        // Keyboard Check
        char key = 0;
        Wire.requestFrom(CARDKB_ADDR, 1);
        if(Wire.available()) { char c = Wire.read(); if(c != 0) key = c; }

        // LED Logic (Button Controlled)
        uint16_t nextPcf = 0xFFFF; 
        if (btnA) nextPcf |= (1 << PCF_LED_R); else nextPcf &= ~(1 << PCF_LED_R);
        if (btnB) nextPcf |= (1 << PCF_LED_G); else nextPcf &= ~(1 << PCF_LED_G);
        if (btnC) nextPcf |= (1 << PCF_LED_B); else nextPcf &= ~(1 << PCF_LED_B);
        if (btnD) nextPcf |= (1 << PCF_LED_R) | (1 << PCF_LED_G) | (1 << PCF_LED_B);
        pcfWrite(nextPcf);

        // Update Values (No Clear Screen)
        tft.setTextSize(2);
        
        tft.setCursor(110, 40);
        tft.setTextColor(btnA ? TFT_GREEN : TFT_RED, TFT_BLACK); tft.print("A ");
        tft.setTextColor(btnB ? TFT_GREEN : TFT_RED, TFT_BLACK); tft.print("B ");
        tft.setTextColor(btnC ? TFT_GREEN : TFT_RED, TFT_BLACK); tft.print("C ");
        tft.setTextColor(btnD ? TFT_GREEN : TFT_RED, TFT_BLACK); tft.print("D ");

        tft.setCursor(60, 70); tft.setTextColor(TFT_WHITE, TFT_BLACK); tft.print(potVal); tft.print("   ");
        tft.setCursor(50, 100); tft.print(irVal); tft.print("   ");
        tft.setCursor(60, 130); tft.print(pir ? "DETECTED" : "WAITING ");
        
        tft.setCursor(70, 160); tft.setTextColor(TFT_MAGENTA, TFT_BLACK);
        if (rfidDetected) { tft.print(rfidUid); tft.print("   "); } else { tft.print("Scanning...   "); }
        
        tft.setCursor(60, 190); tft.setTextColor(TFT_ORANGE, TFT_BLACK);
        if (key) { tft.print(key); tft.print("   "); } else { tft.print("-   "); }
      }
      
      if (btnB) { currentState = STATE_MENU; delay(300); }
      break;

    // *** RGB TEST MODE ***
    case STATE_RGB:
      // Map Pot to Color Index (0-4)
      rgbStep = map(potVal, 0, 4096, 0, 5);
      if (rgbStep > 4) rgbStep = 4;

      if (currentState != lastState || rgbStep != lastRgbStep) {
        if (currentState != lastState) {
            tft.fillScreen(TFT_BLACK);
            tft.setTextSize(2);
            tft.setCursor(0, 0); tft.setTextColor(TFT_WHITE, TFT_BLACK); tft.println(" RGB LED TEST");
            tft.drawLine(0, 20, 320, 20, TFT_WHITE);
            tft.setCursor(0, 220); tft.setTextColor(TFT_DARKGREY, TFT_BLACK); tft.print("BtnB: Back to Menu");
            lastState = currentState;
        }
        
        uint16_t testPcf = 0xFFFF;
        testPcf &= ~((1 << PCF_LED_R) | (1 << PCF_LED_G) | (1 << PCF_LED_B)); // All Off
        uint16_t color = TFT_BLACK;
        String colorName = "";
        
        if (rgbStep == 0) { color = TFT_BLACK; colorName = "OFF  "; }
        else if (rgbStep == 1) { testPcf |= (1 << PCF_LED_R); color = TFT_RED; colorName = "RED  "; }
        else if (rgbStep == 2) { testPcf |= (1 << PCF_LED_G); color = TFT_GREEN; colorName = "GREEN"; }
        else if (rgbStep == 3) { testPcf |= (1 << PCF_LED_B); color = TFT_BLUE; colorName = "BLUE "; }
        else if (rgbStep == 4) { testPcf |= (1 << PCF_LED_R) | (1 << PCF_LED_G) | (1 << PCF_LED_B); color = TFT_WHITE; colorName = "WHITE"; }
        pcfWrite(testPcf);
        
        tft.fillRect(100, 60, 120, 100, color);
        tft.drawRect(99, 59, 122, 102, TFT_WHITE); // Border
        tft.setCursor(120, 180); tft.setTextColor(TFT_WHITE, TFT_BLACK); tft.print(colorName);
        
        lastRgbStep = rgbStep;
      }
      if (btnB) { currentState = STATE_MENU; pcfWrite(0xFFFF); delay(300); }
      break;

    // *** PIR GRAPH MODE ***
    case STATE_PIR:
      if (millis() - lastUiUpdate > 50) { // Update graph faster (50ms)
        lastUiUpdate = millis();
        
        // Update History
        pirHistory[pirGraphX] = pir ? 1 : 0;
        pirGraphX++;
        if (pirGraphX >= GRAPH_W) pirGraphX = 0;
        
        // Draw UI
        // Only clear if entering state
        if (currentState != lastState) {
            tft.fillScreen(TFT_BLACK);
            tft.setTextSize(2);
            tft.setCursor(0, 0); tft.setTextColor(TFT_WHITE, TFT_BLACK); tft.println(" PIR SENSOR TEST");
            tft.drawLine(0, 20, 320, 20, TFT_WHITE);
            tft.setTextSize(1);
            tft.setCursor(0, 180); tft.setTextColor(TFT_LIGHTGREY, TFT_BLACK);
            tft.println("Note: If stuck DETECTED, check wiring.");
            tft.println("Disconnected wire reads HIGH (Detected).");
            tft.setTextSize(2);
            tft.setCursor(0, 220); tft.setTextColor(TFT_DARKGREY, TFT_BLACK); tft.print("BtnB: Back to Menu");
            lastState = currentState;
        }
        
        // Big Status (Update only text area)
        tft.setCursor(20, 40);
        if (pir) {
           tft.setTextColor(TFT_RED, TFT_BLACK); tft.setTextSize(3); tft.print("DETECTED");
        } else {
           tft.setTextColor(TFT_GREEN, TFT_BLACK); tft.setTextSize(3); tft.print("CLEAR   ");
        }
        
        // Graph (Redraw only graph area)
        tft.fillRect(39, 99, GRAPH_W + 2, 62, TFT_BLACK); // Clear graph area only
        tft.drawRect(39, 99, GRAPH_W + 2, 62, TFT_WHITE);
        for (int i = 0; i < GRAPH_W; i++) {
           int val = pirHistory[i];
           int x = 40 + i;
           int y = 160 - (val * 60); // Bottom if 0, Top if 1
           tft.drawPixel(x, y, TFT_GREEN);
           // Draw vertical line for visibility
           if (val) tft.drawFastVLine(x, 100, 60, TFT_DARKGREEN);
        }
        
        // Cursor line
        tft.drawFastVLine(40 + pirGraphX, 100, 60, TFT_RED);
      }
      if (btnB) { currentState = STATE_MENU; delay(300); }
      break;

    // *** SPEAKER TEST MODE ***
    case STATE_SPEAKER:
      if (currentState != lastState) {
        tft.fillScreen(TFT_BLACK);
        tft.setTextSize(2);
        tft.setCursor(0, 0); tft.setTextColor(TFT_CYAN, TFT_BLACK); tft.println(" SPEAKER TEST");
        tft.drawLine(0, 20, 320, 20, TFT_WHITE);
        tft.setTextSize(2);
        tft.setCursor(20, 60); tft.setTextColor(TFT_GREEN, TFT_BLACK); tft.println("BtnA: Scale");
        tft.setCursor(20, 100); tft.setTextColor(TFT_YELLOW, TFT_BLACK); tft.println("BtnC: Melody");
        tft.setCursor(20, 140); tft.setTextColor(TFT_RED, TFT_BLACK); tft.println("BtnD: Siren");
        tft.setCursor(0, 220); tft.setTextColor(TFT_DARKGREY, TFT_BLACK); tft.print("BtnB: Back to Menu");
        lastState = currentState;
      }

      if (btnA) {
        // Play Scale
        int notes[] = {262, 294, 330, 349, 392, 440, 494, 523};
        for (int i=0; i<8; i++) {
            ledcWriteTone(PIN_SPKR, notes[i]);
            delay(200);
        }
        ledcWriteTone(PIN_SPKR, 0);
      }
      
      if (btnC) {
         // Simple Tune
         int melody[] = {262, 392, 349, 330, 294, 523, 392, 349, 330, 294, 523};
         int durs[]   = {500, 500, 100, 100, 100, 500, 300, 100, 100, 100, 500};
         for (int i=0; i<11; i++) {
            ledcWriteTone(PIN_SPKR, melody[i]);
            delay(durs[i]);
            ledcWriteTone(PIN_SPKR, 0);
            delay(50);
         }
      }

      if (btnD) {
        // Siren
        for(int i=0; i<3; i++) {
            for(int f=400; f<1000; f+=20) { ledcWriteTone(PIN_SPKR, f); delay(5); }
            for(int f=1000; f>400; f-=20) { ledcWriteTone(PIN_SPKR, f); delay(5); }
        }
        ledcWriteTone(PIN_SPKR, 0);
      }

      if (btnB) { currentState = STATE_MENU; delay(300); }
      break;
  }
}